package cmd

import (
	"fmt"
	"io"
	"os"
	"path/filepath"
	"strings"

	"github.com/sotarok/gw/internal/git"
	"github.com/spf13/cobra"
)

var (
	shellIntegrationShowScript bool
	shellIntegrationShell      string
	shellIntegrationPrintPath  string
)

var shellIntegrationCmd = &cobra.Command{
	Use:   "shell-integration",
	Short: "Shell integration utilities",
	Long: `Shell integration utilities for gw.

Use --show-script to output shell integration code that can be eval'd:
  eval "$(gw shell-integration --show-script --shell=zsh)"

Use --print-path to get the worktree path for a specific issue or branch:
  cd $(gw shell-integration --print-path=123)`,
	RunE: runShellIntegration,
}

func init() {
	shellIntegrationCmd.Flags().BoolVar(&shellIntegrationShowScript, "show-script", false, "Output shell integration script")
	shellIntegrationCmd.Flags().StringVar(&shellIntegrationShell, "shell", "", "Shell type (bash, zsh, fish). Auto-detected if not specified")
	shellIntegrationCmd.Flags().StringVar(&shellIntegrationPrintPath, "print-path", "",
		"Print worktree path for the specified issue or branch")
	rootCmd.AddCommand(shellIntegrationCmd)
}

func runShellIntegration(cmd *cobra.Command, args []string) error {
	shellCmd := NewShellIntegrationCommand(os.Stdout, os.Stderr)
	shellCmd.showScript = shellIntegrationShowScript
	shellCmd.shell = shellIntegrationShell
	shellCmd.printPath = shellIntegrationPrintPath
	return shellCmd.Execute()
}

// ShellIntegrationCommand handles the shell-integration command logic
type ShellIntegrationCommand struct {
	stdout     io.Writer
	stderr     io.Writer
	showScript bool
	shell      string
	printPath  string
}

// NewShellIntegrationCommand creates a new shell integration command handler
func NewShellIntegrationCommand(stdout, stderr io.Writer) *ShellIntegrationCommand {
	return &ShellIntegrationCommand{
		stdout: stdout,
		stderr: stderr,
	}
}

// Execute runs the shell integration command
func (c *ShellIntegrationCommand) Execute() error {
	// Validate flags
	if !c.showScript && c.printPath == "" {
		return fmt.Errorf("either --show-script or --print-path must be specified")
	}
	if c.showScript && c.printPath != "" {
		return fmt.Errorf("cannot use both --show-script and --print-path")
	}

	if c.showScript {
		return c.showShellScript()
	}

	return c.printWorktreePath()
}

func (c *ShellIntegrationCommand) showShellScript() error {
	// Auto-detect shell if not specified
	shell := c.shell
	if shell == "" {
		shell = c.detectShell()
	}

	// Validate shell
	switch shell {
	case shellBash, shellZsh:
		fmt.Fprint(c.stdout, c.getBashZshScript(shell))
	case shellFish:
		fmt.Fprint(c.stdout, c.getFishScript())
	default:
		return fmt.Errorf("unsupported shell: %s (supported: bash, zsh, fish)", shell)
	}

	return nil
}

func (c *ShellIntegrationCommand) detectShell() string {
	// First try SHELL environment variable
	shellPath := os.Getenv("SHELL")
	shell := filepath.Base(shellPath)

	switch {
	case strings.Contains(shell, shellZsh):
		return shellZsh
	case strings.Contains(shell, shellBash):
		return shellBash
	case strings.Contains(shell, shellFish):
		return shellFish
	default:
		// Default to bash if we can't detect
		return shellBash
	}
}

func (c *ShellIntegrationCommand) getBashZshScript(shell string) string {
	shebang := "#!/bin/bash"
	if shell == shellZsh {
		shebang = "#!/bin/zsh"
	}

	return fmt.Sprintf(`%s
# gw shell integration
# This script is dynamically generated by 'gw shell-integration --show-script'
# Add to your shell configuration with: eval "$(gw shell-integration --show-script --shell=%s)"

gw() {
    # Check if we should auto-cd after command
    if [[ "$1" == "start" || "$1" == "checkout" ]] && [[ -f ~/.gwrc ]]; then
        # Check if auto_cd is enabled
        if grep -q "auto_cd = true" ~/.gwrc 2>/dev/null; then
            # Run the actual command (output goes directly to terminal)
            command gw "$@"
            local exit_code=$?
            
            # If command succeeded, get the worktree path and cd to it
            if [[ $exit_code -eq 0 ]]; then
                local identifier="${2:-}"  # Get issue number or branch name
                if [[ -n "$identifier" ]]; then
                    # Get the worktree path using shell-integration command
                    local worktree_path=$(command gw shell-integration --print-path="$identifier" 2>/dev/null)
                    
                    # If we got a path, cd to it
                    if [[ -n "$worktree_path" && -d "$worktree_path" ]]; then
                        cd "$worktree_path"
                        echo "Changed directory to: $worktree_path"
                    fi
                fi
            fi
            
            return $exit_code
        else
            # Auto CD disabled, just run the command normally
            command gw "$@"
        fi
    else
        # Not a start/checkout command, just run normally
        command gw "$@"
    fi
}
`, shebang, shell)
}

func (c *ShellIntegrationCommand) getFishScript() string {
	return `#!/usr/bin/env fish
# gw shell integration for Fish
# This script is dynamically generated by 'gw shell-integration --show-script'
# Add to your shell configuration with: gw shell-integration --show-script --shell=fish | source

function gw
    # Check if we should auto-cd after command
    if test "$argv[1]" = "start" -o "$argv[1]" = "checkout"
        if test -f ~/.gwrc
            # Check if auto_cd is enabled
            if grep -q "auto_cd = true" ~/.gwrc 2>/dev/null
                # Run the actual command (output goes directly to terminal)
                command gw $argv
                set exit_code $status
                
                # If command succeeded, get the worktree path and cd to it
                if test $exit_code -eq 0
                    set identifier "$argv[2]"  # Get issue number or branch name
                    if test -n "$identifier"
                        # Get the worktree path using shell-integration command
                        set worktree_path (command gw shell-integration --print-path="$identifier" 2>/dev/null)
                        
                        # If we got a path, cd to it
                        if test -n "$worktree_path" -a -d "$worktree_path"
                            cd "$worktree_path"
                            echo "Changed directory to: $worktree_path"
                        end
                    end
                end
                
                return $exit_code
            else
                # Auto CD disabled, just run the command normally
                command gw $argv
            end
        else
            # No config file, just run normally
            command gw $argv
        end
    else
        # Not a start/checkout command, just run normally
        command gw $argv
    end
end
`
}

func (c *ShellIntegrationCommand) printWorktreePath() error {
	if c.printPath == "" {
		return fmt.Errorf("--print-path requires an issue number or branch name")
	}

	// Use git client to find worktree
	gitClient := git.NewDefaultClient()

	// Check if we're in a git repository
	if !gitClient.IsGitRepository() {
		return fmt.Errorf("not in a git repository")
	}

	// Try to find the worktree path
	worktreePath, err := findWorktreePath(gitClient, c.printPath)
	if err != nil {
		// Don't print error message, just return non-zero exit code
		// Shell function will check exit code
		return err
	}

	// Print only the path
	fmt.Fprintln(c.stdout, worktreePath)
	return nil
}

func findWorktreePath(gitClient git.Interface, identifier string) (string, error) {
	// Get repository name
	repoName, err := gitClient.GetRepositoryName()
	if err != nil {
		return "", err
	}

	// First, check if the expected directory exists (most common case after 'gw start')
	// This works even if git worktree list hasn't updated yet
	expectedPath := filepath.Join("..", fmt.Sprintf("%s-%s", repoName, identifier))
	absPath, err := filepath.Abs(expectedPath)
	if err == nil {
		if info, err := os.Stat(absPath); err == nil && info.IsDir() {
			return absPath, nil
		}
	}

	// Next, try to find via git worktree list
	worktrees, err := gitClient.ListWorktrees()
	if err == nil {
		for _, wt := range worktrees {
			// Check for exact branch match
			if wt.Branch == identifier {
				return wt.Path, nil
			}
			// Check if branch matches issue pattern (e.g., "123/impl")
			if strings.HasPrefix(wt.Branch, identifier+"/") {
				return wt.Path, nil
			}
		}
	}

	// If not found as issue, try as branch name (for checkout command)
	sanitizedBranchName := gitClient.SanitizeBranchNameForDirectory(identifier)
	if sanitizedBranchName != identifier {
		expectedPath = filepath.Join("..", fmt.Sprintf("%s-%s", repoName, sanitizedBranchName))
		absPath, err = filepath.Abs(expectedPath)
		if err == nil {
			if info, err := os.Stat(absPath); err == nil && info.IsDir() {
				return absPath, nil
			}
		}
	}

	return "", fmt.Errorf("worktree not found for: %s", identifier)
}
